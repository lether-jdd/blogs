# 1 已知数据结构users，请实现语法支持users.unique能够按照name字段去重，并输出结构为：["a","b"]
```bash
var users=[{
   id:1,name:"a"
},{
   id:2,name:"a"
},{
   id:3,name:"b"
},{
   id:4,name:"v"
}]
Array.prototype.unique = function () {
    var res;
    this.map(item => {
        this[item.id - 1] = item.name  
    })
    // ES6里新添加了两个很好用的东西，set和Array.from
    // set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去重其中的重复项目。
    res=new Set(this);
    console.log("new Set对象",res)
    // 但是这里大家可以看到，set返回的是一个对象，但是我们想要的是数组啊。
    // 这回，就该轮到Array.from出场了，它的作用，就是可以把类数组对象、可迭代对象转化为数组。
    res=Array.from(new Set(this));
    return  res//es6 数组去重
}
```
> 扩展：set 能够去重，参数为数组或类数组对象
# 2 已知如下对象，请基于es6的proxy方法设计一个属性拦截读取操作的例子，要求实现去访问目标对象example中不存在的属性时，抛出错误：Property "$(property)" does not exist
```bash
const man={
    name:'jscoder',
    age:22
}

new proxy(man,{
  get:function(target, property){
    if(property in target){
    if(property in target){
      return target[property]
    }else{
      throw new ReferenceError(`Property ${property} does not exist.`);
    }
  }
})
```
> 扩展：proxy 写法的熟悉还有别的拦截(set等)
>      错误处理及错误类型：ReferenceError：引用类型错误（当一个不存在的变量被引用时发生的错误）
>                       throw和错误类型：SyntaxError，TypeError，EvalError等6个
# 3 给出如下虚拟dom的数据结构，如何实现简单的虚拟dom，渲染到目标dom树
```bash
let demoNode = {
    tagName: 'ul',
    props: {'class': 'list'},
    children: [
        ({tagName: 'li', children: ['douyin']}),
        ({tagName: 'li', children: ['toutiao']})
    ]
};
let e = document.createElement
let e1 = document.createTextNode
function render(demoNode,targetElem){
  let node ;
  if(!demoNode.tagName){
    node = e1(demoNode)
    targetElem.appendChild(node);
    return 
  }
  node = e(demoNode.tagName)
  Object.keys(demoNode.props) && Object.keys(demoNode.props).forEach(i=>{
    node.setAttribute(i,demoNode.props[i])
  })
  demoNode.children && demoNode.children.forEach(i=>{
    render(i,node)
  })
  targetElem.appendChild(node);
}
```
# 4 给定一个数组排序，使得奇数位的值不大于相邻偶数位的值。