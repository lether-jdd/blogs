来源：http://yanruoqin.com/js-async/004.html#%E9%97%AE%E9%A2%98
# 1 回调地狱
回调嵌套回调
回调的坏处：
1 多层嵌套，不易维护
2 错误处理，每层嵌套都需要对于成功失败分别做处理
# 2 promise 链式调用，避免嵌套
1 回调函数延迟绑定（通过then传入）
2 返回值穿透（返回也是promise）
3 错误冒泡
```bash
readFilePromise('1.json').then(data => {
    return readFilePromise('2.json');
}).then(data => {
    return readFilePromise('3.json');
}).then(data => {
    return readFilePromise('4.json');
}).catch(err => {
  // xxx
})
这样前面产生的错误会一直向后传递，被 catch 接收到，就不用频繁地检查错误了。
```
对于promise中未能捕获的错误，可以通过监听window的unhandledrejection来捕获

## 2.1 promise是同步的，只是里面的resolve和reject是异步的，这两个是作为微任务放到事件循环中的
## 2.2 怎么实现一个promise
```bash
1 内部状态流转
2 then 方法
3 reject和resolve
function Promise(fun){
  this.status = 'pending'
  this.fill =null
  this.reject = null
  function resolve(val){
    if(this.status != pending) return
    this.fill(val)
    this.status = 'resolve'
  }
  function rejectfun(err){
    if(this.status != pending) return
    this.reject(err)
    this.status = 'reject'
  }
  fun(resolve,rejectfun)
}
Promise.prototype.then = function(full,reject){
  if(this.status = 'pending'){
    this.full = full
    this.reject = reject
  }else if (this.status === FULFILLED) {
    //如果状态是fulfilled,则执行成功回调，并将成功值传入
    onFulfilled(this.value);
  } else {
    //如果状态是rejected，直接执行失败回调，并将失败原因传入
    onRejected(this.error);
  }
  return 新的promise
}
```
# 2.3  promise 的缺点
创建即执行，不能取消
无法获知执行状态


# 3 generator和协程
生成器是es6的语法
生成器语法
```bash
function * gen(){
  a = yeild funtion(){}
  b = yeild funtion(){}
}
g = gen()
g.next()
1 调用 gen() 后，程序会阻塞住，不会执行任何语句。
2 调用 g.next() 后，程序继续执行，直到遇到 yield 程序暂停。
3 next 方法返回一个对象， 有两个属性: value 和 done。value 为当前 yield 后面的结果，done 表示是否执行完，遇到了return 后，done 会由false变为true。
```
## 3.1 生成器是如何让程序停止和恢复的
1 协程：
协程是一种比线程更加轻量级的存在，协程处在线程的环境中，一个线程可以存在多个协程，可以将协程理解为线程中的一个个任务。不像进程和线程，协程并不受操作系统的管理，而是被具体的应用程序代码所控制。
2 协程的运作
一个线程一次只能执行一个协程。比如当前执行 A 协程，另外还有一个 B 协程，如果想要执行 B 的任务，就必须在 A 协程中将JS 线程的控制权转交给 B协程，那么现在 B 执行，A 就相当于处于暂停的状态。
3 如何让generator的异步函数顺序执行
```bash
const readFileThunk = (filename) => {
  return (callback) => {
    fs.readFile(filename, callback);
  }
}
const gen = function* () {
  const data1 = yield readFileThunk('001.txt')
  console.log(data1.toString())
  const data2 = yield readFileThunk('002.txt')
  console.log(data2.toString)
}
let g = gen();
// 第一步: 由于进场是暂停的，我们调用next，让它开始执行。
// next返回值中有一个value值，这个value是yield后面的结果，放在这里也就是是thunk函数生成的定制化函数，里面需要传一个回调函数作为参数
g.next().value((err, data1) => {
  // 第二步: 拿到上一次得到的结果，调用next, 将结果作为参数传入，程序继续执行。
  // 同理，value传入回调
  g.next(data1).value((err, data2) => {
    g.next(data2);
  })
})
```
也可以通过promise来实现
最终是利用co这个库
# 4 async 和await   
es7中新增的(2016年)
async/await被称为 JS 中异步终极解决方案
async/await利用协程和Promise实现了同步方式编写异步代码的效果
async 是一个通过异步执行并隐式返回 Promise 作为结果的函数
await 对后面返回的promise执行then
# 4.1 foreach中async不能顺序执行，但是for of 却可以
因为for  of是用迭代器去遍历的（生成器本身就是一个迭代器）


