文章：https://juejin.im/post/5d67662ee51d45621655353f#heading-15   实现方法也很详细
# 1 BA认证(BASE64)
适用于：简单的账号密码验证，不需要记录状态，安全环境
HTTP协议定义了基本认证允许HTTP服务器对客户端进行用户身份证的方法。
过程：
1 客户端请求不带Authorization
2 服务端会返回401，WWW-Authenticate: Basic realm=”google.com” 
3 浏览器收到401弹出登录弹框
4 用户输入之后，将用户名及密码以BASE64加密方式加密，并将密文放入前一条请求信息中发出
5 服务器收到上述请求信息后，将 Authorization 字段后的用户信息取出、解密，将解密后的用户名及密码与用户数据库进行比较验证
缺点：
需要在安全的环境中，不然以明文传输的密钥和口令很容易被拦截
git  使用的BA认证
# 2 session-cookie认证(唯一标识sid,也可以签名)
适用于：浏览器环境，记录状态
过程：
1 客户端带上账户、密码访问服务端（其实就是登陆过程）
2 服务端创建session,存在内存或缓存，然后给这个session生成一个唯一的标识字符串,然后在 响应头中种下这个唯一标识字符串(sid:session id)，也可在这里对sid进行签名处理（setcookie）。
3 浏览览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的请求头中会带上该域名下的cookie信息。
4 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。
缺点：
1 认证方式局限于在浏览器中使用，cookie 是浏览器端的机制，如果在app端就无法使用 cookie
2 为了满足全局一致性，我们最好把 session 存储在 redis 中做持久化，而在分布式环境下，我们可能需要在每个服务器上都备份，占用了大量的存储空间。 
3 在不是 Https 协议下使用 cookie ，容易受到 CSRF 跨站点请求伪造攻击。
# 3 token（跟session-cookie很像，但是并不存储在服务端）
适用于：可以不在浏览器环境
token 由用户信息、时间戳和由 hash 算法加密的签名构成。
过程
1 客户端使用用户名跟密码请求登录
2 服务端收到请求，去验证用户名与密码
3 验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端
4 客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者Local Storage 里
5 客户端每次向服务端请求资源的时候需要带着服务端签发的 Token
6 服务端收到请求，然后去验证客户端请求里面带着的 Token（request头部添加Authorization），如果验证成功，就向客户端返回请求的数据 ，如果不成功返回401错误码，鉴权失败。
缺点：
1 加密解密消耗使得 token 认证比 session-cookie 更消耗性能。
2 token 比 sessionId 大，更占带宽。
# 4 JWT（JSON Web Token）
适用于：简单的场景，比较安全的环境
服务器认证以后，生成一个 JSON 对象，签名加密后返回给用户，以后用户每次访问服务器端就带着这张令牌。
这个 JSON 对象可能包含的内容就是用户的信息，用户的身份以及令牌的过期时间。
json包含三部分信息：Header（头部）：加密算法、Payload（负载）：用户信息等、Signature（签名）：对前面两个部分的签名，防止数据篡改
缺点：
1 JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
2 JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
3 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。
# 5 开放授权OAuth（例如：经授权允许某网站使用用户的qq登录）
常见的提供OAuth认证服务的厂商有支付宝，QQ,微信。
OAuth就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。
第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。
过程：
1 使用申请的第三方身份识别码（id+密钥）请求认证服务
2 认证服务重定向到登录页面
3 用户输入用户的账号密码
4 开放服务端验证后会拼接授权码重定向到第三方网站
5 第三方服务拿着授权码，身份标识请求开放服务得到access_token令牌
6 第三方服务暂时拥有开放服务的权限

第三方服务一般不缓存session,会造成过期不同步问题
# 补充
## 签名：
用私钥加密的消息称为签名，只有拥有私钥的用户可以生成签名。
用公钥解密签名这一步称为验证签名，所有用户都可以验证签名(因为公钥是公开的)
### 生成签名
一般不直接对消息进行签名，而是对消息的哈希值进行签名
1 对消息进行哈希计算，得到哈希值
2 利用私钥对哈希值进行加密，生成签名
3 将签名附加在消息后面，一起发送过去
### 验证签名
收到消息后，提取消息中的签名
用公钥对签名进行解密，得到哈希值1。
对消息中的正文进行哈希计算，得到哈希值2。
比较哈希值1和哈希值2，如果相同，则验证成功。
## 证书
证书实际上就是对公钥进行数字签名，它是对公钥合法性提供证明的技术。
### 如何生成证书？
服务器将公钥A给CA（公钥是服务器的）
CA用自己的私钥B给公钥A加密，生成数字签名A
CA把公钥A，数字签名A，附加一些服务器信息整合在一起，生成证书，发回给服务器。
### 如何验证证书？
客户端得到证书
客户端得到证书的公钥B（通过CA或其它途径）
客户端用公钥B对证书中的数字签名解密，得到哈希值
客户端对公钥进行哈希值计算
两个哈希值对比，如果相同，则证书合法。